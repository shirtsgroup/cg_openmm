

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cg_openmm.parameters.secondary_structure &mdash; cg_openmm  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> cg_openmm
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">CGModel class:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../cgmodel_class.html">CGModel class</a></li>
</ul>
<p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">cg_openmm</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>cg_openmm.parameters.secondary_structure</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for cg_openmm.parameters.secondary_structure</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">simtk.unit</span> <span class="k">as</span> <span class="nn">unit</span>
<span class="kn">from</span> <span class="nn">statistics</span> <span class="kn">import</span> <span class="n">mean</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">linregress</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">spatial</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.backends.backend_pdf</span> <span class="kn">import</span> <span class="n">PdfPages</span>
<span class="kn">from</span> <span class="nn">cg_openmm.utilities.random_builder</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">cg_openmm.utilities.iotools</span> <span class="kn">import</span> <span class="n">write_pdbfile_without_topology</span>
<span class="kn">from</span> <span class="nn">openmmtools.multistate</span> <span class="kn">import</span> <span class="n">MultiStateReporter</span><span class="p">,</span> <span class="n">ReplicaExchangeAnalyzer</span>
<span class="kn">import</span> <span class="nn">pymbar</span>
<span class="kn">from</span> <span class="nn">pymbar</span> <span class="kn">import</span> <span class="n">timeseries</span>
<span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">md</span>

<span class="n">kB</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="n">MOLAR_GAS_CONSTANT_R</span> <span class="c1"># Boltzmann constant</span>

<div class="viewcode-block" id="get_native_contacts"><a class="viewcode-back" href="../../../index.html#cg_openmm.parameters.secondary_structure.get_native_contacts">[docs]</a><span class="k">def</span> <span class="nf">get_native_contacts</span><span class="p">(</span><span class="n">cgmodel</span><span class="p">,</span> <span class="n">native_structure_file</span><span class="p">,</span> <span class="n">native_contact_distance_cutoff</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a coarse grained model, positions for that model, and positions for the native structure, this function calculates the fraction of native contacts for the model.</span>

<span class="sd">        :param cgmodel: CGModel() class object</span>
<span class="sd">        :type cgmodel: class</span>

<span class="sd">        :param native_structure_file: Path to file (&#39;pdb&#39; or &#39;dcd&#39;) containing particle positions for the native structure.</span>
<span class="sd">        :type native_structure_file: str</span>

<span class="sd">        :param native_contact_distance_cutoff: The maximum distance for two nonbonded particles that are defined as &quot;native&quot;,default=None</span>
<span class="sd">        :type native_contact_distance_cutoff: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_</span>

<span class="sd">        :returns:</span>
<span class="sd">          - native_contact_list - A list of the nonbonded interactions whose inter-particle distances are less than the &#39;native_contact_cutoff_distance&#39;.</span>
<span class="sd">          - native_contact_distances - A Quantity numpy array of the native pairwise distances corresponding to native_contact_list</span>
<span class="sd">          - contact_type_dict - A dictionary of {native contact particle type pair: counts}</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="c1"># Parse native structure file</span>
    <span class="k">if</span> <span class="n">native_structure_file</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;dcd&#39;</span><span class="p">:</span>
        <span class="n">native_traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">native_structure_file</span><span class="p">,</span><span class="n">top</span><span class="o">=</span><span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">from_openmm</span><span class="p">(</span><span class="n">cgmodel</span><span class="o">.</span><span class="n">topology</span><span class="p">))</span>
        <span class="c1"># ***Note: The clustering dcds are written with unit nanometers,</span>
        <span class="c1"># but this may not always be the case.</span>
        <span class="n">native_structure</span> <span class="o">=</span> <span class="n">native_traj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">nanometer</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">native_structure</span> <span class="o">=</span> <span class="n">PDBFile</span><span class="p">(</span><span class="n">native_structure_file</span><span class="p">)</span><span class="o">.</span><span class="n">getPositions</span><span class="p">()</span>
        
    <span class="n">nonbonded_interaction_list</span> <span class="o">=</span> <span class="n">cgmodel</span><span class="o">.</span><span class="n">nonbonded_interaction_list</span>
    <span class="n">native_structure_distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">(</span><span class="n">nonbonded_interaction_list</span><span class="p">,</span> <span class="n">native_structure</span><span class="p">)</span>
    <span class="n">native_contact_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">native_contact_distances_list</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">interaction</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nonbonded_interaction_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">native_structure_distances</span><span class="p">[</span><span class="n">interaction</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">native_contact_distance_cutoff</span><span class="p">):</span>
            <span class="n">native_contact_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nonbonded_interaction_list</span><span class="p">[</span><span class="n">interaction</span><span class="p">])</span>
            <span class="n">native_contact_distances_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distances</span><span class="p">(</span><span class="n">native_contact_list</span><span class="p">,</span> <span class="n">native_structure</span><span class="p">))</span>
    
    <span class="c1"># Units get messed up if converted using np.asarray</span>
    <span class="n">native_contact_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">native_contact_distances_list</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">native_contact_distances_list</span><span class="p">)):</span>
        <span class="n">native_contact_distances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">native_contact_distances_list</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">nanometer</span><span class="p">)</span>
    <span class="n">native_contact_distances</span> <span class="o">*=</span> <span class="n">unit</span><span class="o">.</span><span class="n">nanometer</span>
    
    <span class="c1"># Determine particle types of the native contacts:</span>
    <span class="c1"># Store the numbers of contact interactions by type in dict:</span>
    <span class="n">contact_type_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">contact</span> <span class="ow">in</span> <span class="n">native_contact_list</span><span class="p">:</span>
        <span class="n">type1</span> <span class="o">=</span> <span class="n">cgmodel</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">contact</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">type2</span> <span class="o">=</span> <span class="n">cgmodel</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">contact</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">string_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">type1</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">type2</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">reverse_string_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">type2</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">type1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">string_name</span> <span class="ow">in</span> <span class="n">contact_type_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> 
            <span class="p">(</span><span class="n">reverse_string_name</span> <span class="ow">in</span> <span class="n">contact_type_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Found a new type of contact:</span>
            <span class="c1"># Only store counts in forward string of first encounter</span>
            <span class="n">contact_type_dict</span><span class="p">[</span><span class="n">string_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;adding contact type </span><span class="si">{</span><span class="n">string_name</span><span class="si">}</span><span class="s2"> to dict&quot;</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">string_name</span> <span class="ow">in</span> <span class="n">contact_type_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Add to forward_string count:</span>
                <span class="n">contact_type_dict</span><span class="p">[</span><span class="n">string_name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Add to reverse string count:</span>
                <span class="n">contact_type_dict</span><span class="p">[</span><span class="n">reverse_string_name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            
    <span class="k">return</span> <span class="n">native_contact_list</span><span class="p">,</span> <span class="n">native_contact_distances</span><span class="p">,</span> <span class="n">contact_type_dict</span></div>


<div class="viewcode-block" id="expectations_fraction_contacts"><a class="viewcode-back" href="../../../index.html#cg_openmm.parameters.secondary_structure.expectations_fraction_contacts">[docs]</a><span class="k">def</span> <span class="nf">expectations_fraction_contacts</span><span class="p">(</span><span class="n">fraction_native_contacts</span><span class="p">,</span> <span class="n">temperature_list</span><span class="p">,</span> <span class="n">frame_begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_spacing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">output_data</span><span class="o">=</span><span class="s2">&quot;output/output.nc&quot;</span><span class="p">,</span> <span class="n">num_intermediate_states</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a .nc output, a temperature list, and a number of intermediate states to insert for the temperature list, this function calculates the native contacts expectation.   </span>
<span class="sd">    </span>
<span class="sd">    :param fraction_native_contacts: The fraction of native contacts for all selected frames in the trajectories.</span>
<span class="sd">    :type fraction_native_contacts: numpy array (float * nframes x nreplicas)</span>
<span class="sd">    </span>
<span class="sd">    :param temperature_list: List of temperatures corresponding to the states in the .nc output file</span>
<span class="sd">    :type temperature: List( float * simtk.unit.temperature )</span>
<span class="sd">    </span>
<span class="sd">    :param frame_begin: index of first frame defining the range of samples to use as a production period (default=0)</span>
<span class="sd">    :type frame_begin: int</span>

<span class="sd">    :param sample_spacing: spacing of uncorrelated data points, for example determined from pymbar timeseries subsampleCorrelatedData</span>
<span class="sd">    :type sample_spacing: int       </span>
<span class="sd">    </span>
<span class="sd">    :param output_data: Path to the output data for a NetCDF-formatted file containing replica exchange simulation data, default = None                                                                                                  </span>
<span class="sd">    :type output_data: str</span>
<span class="sd">    </span>
<span class="sd">    :param num_intermediate_states: The number of states to insert between existing states in &#39;temperature_list&#39;</span>
<span class="sd">    :type num_intermediate_states: int    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># extract reduced energies and the state indices from the .nc  </span>
    <span class="n">reporter</span> <span class="o">=</span> <span class="n">MultiStateReporter</span><span class="p">(</span><span class="n">output_data</span><span class="p">,</span> <span class="n">open_mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">analyzer</span> <span class="o">=</span> <span class="n">ReplicaExchangeAnalyzer</span><span class="p">(</span><span class="n">reporter</span><span class="p">)</span>
    <span class="p">(</span>
        <span class="n">replica_energies_all</span><span class="p">,</span>
        <span class="n">unsampled_state_energies</span><span class="p">,</span>
        <span class="n">neighborhoods</span><span class="p">,</span>
        <span class="n">replica_state_indices</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">read_energies</span><span class="p">()</span>
    
    <span class="c1"># Select production frames to analyze</span>
    <span class="n">replica_energies</span> <span class="o">=</span> <span class="n">replica_energies_all</span><span class="p">[:,:,</span><span class="n">frame_begin</span><span class="p">::</span><span class="n">sample_spacing</span><span class="p">]</span>
    
    <span class="c1"># Check the size of the fraction_native_contacts array:</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">replica_energies</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fraction_native_contacts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># Mismatch in number of frames.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">replica_energies_all</span><span class="p">[:,:,</span><span class="n">frame_begin</span><span class="p">::</span><span class="n">sample_spacing</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fraction_native_contacts</span><span class="p">[::</span><span class="n">sample_spacing</span><span class="p">,:])[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># Correct starting frame, need to apply sampling stride:</span>
            <span class="n">fraction_native_contacts</span> <span class="o">=</span> <span class="n">fraction_native_contacts</span><span class="p">[::</span><span class="n">sample_spacing</span><span class="p">,:]</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">replica_energies_all</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fraction_native_contacts</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># This is the full fraction_native_contacts, slice production frames:</span>
            <span class="n">fraction_native_contacts</span> <span class="o">=</span> <span class="n">fraction_native_contacts</span><span class="p">[</span><span class="n">production_start</span><span class="p">::</span><span class="n">sample_spacing</span><span class="p">,:]</span>

    <span class="c1"># determine the numerical values of beta at each state in units consistent with the temperature</span>
    <span class="n">Tunit</span> <span class="o">=</span> <span class="n">temperature_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">unit</span>
    <span class="n">temps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">temp</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">Tunit</span><span class="p">)</span>  <span class="k">for</span> <span class="n">temp</span> <span class="ow">in</span> <span class="n">temperature_list</span><span class="p">])</span>  <span class="c1"># should this just be array to begin with</span>
    <span class="n">beta_k</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">kB</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">kilojoule_per_mole</span><span class="o">/</span><span class="n">Tunit</span><span class="p">)</span> <span class="o">*</span> <span class="n">temps</span><span class="p">)</span>

    <span class="c1"># convert the energies from replica/evaluated state/sample form to evaluated state/sample form</span>
    <span class="n">replica_energies</span> <span class="o">=</span> <span class="n">pymbar</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">kln_to_kn</span><span class="p">(</span><span class="n">replica_energies</span><span class="p">)</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">replica_energies</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="c1"># n_samples in [nreplica x nsamples_per_replica]</span>
    
    <span class="c1"># calculate the number of states we need expectations at.  We want it at all of the original</span>
    <span class="c1"># temperatures, each intermediate temperature, and then temperatures +/- from the original</span>
    <span class="c1"># to take finite derivatives.</span>

    <span class="c1"># create  an array for the temperature and energy for each state, including the</span>
    <span class="c1"># finite different state.</span>
    <span class="n">n_sampled_T</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">temps</span><span class="p">)</span>
    <span class="n">n_unsampled_states</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_sampled_T</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_sampled_T</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_intermediate_states</span><span class="p">)</span>
    <span class="n">unsampled_state_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_unsampled_states</span><span class="p">,</span><span class="n">n_samples</span><span class="p">])</span>
    <span class="n">full_T_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_unsampled_states</span><span class="p">)</span>

    <span class="c1"># delta is the spacing between temperatures.</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sampled_T</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># fill in a list of temperatures at all original temperatures and all intermediate states.</span>
    <span class="n">full_T_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">temps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sampled_T</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">temps</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">temps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">num_intermediate_states</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_intermediate_states</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">full_T_list</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">temps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">j</span>
            <span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">full_T_list</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">temps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_T_vals</span> <span class="o">=</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span>

    <span class="c1"># calculate betas of all of these temperatures</span>
    <span class="n">beta_full_k</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">kB</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">kilojoule_per_mole</span><span class="o">/</span><span class="n">Tunit</span><span class="p">)</span> <span class="o">*</span> <span class="n">full_T_list</span><span class="p">)</span>
    
    <span class="n">ti</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">N_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_unsampled_states</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_unsampled_states</span><span class="p">):</span>
        <span class="c1"># Calculate the reduced energies at all temperatures, sampled and unsample.</span>
        <span class="n">unsampled_state_energies</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">replica_energies</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">*</span><span class="p">(</span><span class="n">beta_full_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">beta_k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ti</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">temps</span><span class="p">):</span>
            <span class="c1"># store in N_k which states do and don&#39;t have samples.</span>
            <span class="k">if</span> <span class="n">full_T_list</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">temps</span><span class="p">[</span><span class="n">ti</span><span class="p">]:</span>
                <span class="n">ti</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">N_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_samples</span><span class="o">//</span><span class="nb">len</span><span class="p">(</span><span class="n">temps</span><span class="p">)</span>  <span class="c1"># these are the states that have samples</span>

    <span class="c1"># call MBAR to find weights at all states, sampled and unsampled</span>
    <span class="n">mbarT</span> <span class="o">=</span> <span class="n">pymbar</span><span class="o">.</span><span class="n">MBAR</span><span class="p">(</span><span class="n">unsampled_state_energies</span><span class="p">,</span><span class="n">N_k</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">relative_tolerance</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">);</span>
    
    <span class="c1"># Now we have the weights at all temperatures, so we can</span>
    <span class="c1"># calculate the expectations.</span>
    
    <span class="c1"># Reshape fraction native contacts [nframes x nreplicas] column by column for pymbar</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fraction_native_contacts</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">fraction_native_contacts</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
            
    <span class="c1"># calculate the expectation of Q at each unsampled states         </span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">mbarT</span><span class="o">.</span><span class="n">computeExpectations</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>  <span class="c1"># compute expectations of Q at all points</span>
    <span class="n">Q_expect</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dQ_expect</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># return the results in a dictionary (better than in a list)</span>
    <span class="n">return_results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">return_results</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">full_T_list</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span>
    <span class="n">return_results</span><span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Q_expect</span>
    <span class="n">return_results</span><span class="p">[</span><span class="s2">&quot;dQ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dQ_expect</span>

    <span class="k">return</span> <span class="n">return_results</span></div>

    
<div class="viewcode-block" id="fraction_native_contacts"><a class="viewcode-back" href="../../../index.html#cg_openmm.parameters.secondary_structure.fraction_native_contacts">[docs]</a><span class="k">def</span> <span class="nf">fraction_native_contacts</span><span class="p">(</span>
    <span class="n">cgmodel</span><span class="p">,</span>
    <span class="n">file_list</span><span class="p">,</span>
    <span class="n">native_contact_list</span><span class="p">,</span>
    <span class="n">native_contact_distances</span><span class="p">,</span>
    <span class="n">frame_begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">native_contact_cutoff_ratio</span><span class="o">=</span><span class="mf">1.00</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a cgmodel, mdtraj trajectory object, and positions for the native structure, this function calculates the fraction of native contacts for the model.</span>
<span class="sd">    </span>
<span class="sd">    :param cgmodel: CGModel() class object</span>
<span class="sd">    :type cgmodel: class</span>
<span class="sd">        </span>
<span class="sd">    :param file_list: A list of replica PDB or DCD trajectory files corresponding to the energies in the .nc file, or a single file name</span>
<span class="sd">    :type file_list: List( str ) or str</span>

<span class="sd">    :param native_contact_list: A list of the nonbonded interactions whose inter-particle distances are less than the &#39;native_contact_cutoff_distance&#39;.</span>
<span class="sd">    :type native_contact_list: List</span>
<span class="sd">    </span>
<span class="sd">    :param native_contact_distances: A numpy array of the native pairwise distances corresponding to native_contact_list</span>
<span class="sd">    :type native_contact_distances: Quantity</span>

<span class="sd">    :param frame_begin: Frame at which to start native contacts analysis (default=0)</span>
<span class="sd">    :type frame_begin: int        </span>
<span class="sd">    </span>
<span class="sd">    :param native_contact_cutoff_ratio: The distance below which two nonbonded, interacting particles in a non-native pose are assigned as a &quot;native contact&quot;, as a ratio of the distance for that contact in the native structure, default=1.00</span>
<span class="sd">    :type native_contact_cutoff_ratio: float</span>

<span class="sd">    :returns:</span>
<span class="sd">      - Q ( numpy array (float * nframes x nreplicas) ) - The fraction of native contacts for all selected frames in the trajectories.</span>
<span class="sd">      - Q_avg ( numpy array (float * nreplicas) ) - Mean values of Q for each replica.</span>
<span class="sd">      - Q_stderr ( numpy array (float * nreplicas) ) - Standard error of the mean of Q for each replica.</span>
<span class="sd">      - decorrelation_spacing ( int ) - Number of frames between uncorrelated native contact fractions</span>
<span class="sd">      </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">native_contact_list</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR: there are 0 &#39;native&#39; interactions with the current cutoff distance.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Try increasing the &#39;native_structure_contact_distance_cutoff&#39;&quot;</span><span class="p">)</span>
        <span class="n">exit</span><span class="p">()</span>
        
        
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">n_replicas</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">n_replicas</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Convert to a 1 element list if not one</span>
        <span class="n">file_list</span> <span class="o">=</span> <span class="n">file_list</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
      
    <span class="n">nc_unit</span> <span class="o">=</span> <span class="n">native_contact_distances</span><span class="o">.</span><span class="n">unit</span>
    <span class="n">Q_avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_replicas</span><span class="p">))</span>
    <span class="n">Q_stderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_replicas</span><span class="p">))</span>
      
    <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_replicas</span><span class="p">):</span>            
        <span class="c1"># This should work for pdb or dcd</span>
        <span class="c1"># However for dcd we need to insert a topology, and convert it from openmm-&gt;mdtraj topology </span>
        <span class="k">if</span> <span class="n">file_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s1">&#39;dcd&#39;</span><span class="p">:</span>
            <span class="n">rep_traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_list</span><span class="p">[</span><span class="n">rep</span><span class="p">],</span><span class="n">top</span><span class="o">=</span><span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">from_openmm</span><span class="p">(</span><span class="n">cgmodel</span><span class="o">.</span><span class="n">topology</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rep_traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_list</span><span class="p">[</span><span class="n">rep</span><span class="p">])</span>
        <span class="c1"># Select frames for analysis:</span>
        <span class="n">rep_traj</span> <span class="o">=</span> <span class="n">rep_traj</span><span class="p">[</span><span class="n">frame_begin</span><span class="p">:]</span>
        
        <span class="k">if</span> <span class="n">rep</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nframes</span> <span class="o">=</span> <span class="n">rep_traj</span><span class="o">.</span><span class="n">n_frames</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nframes</span><span class="p">,</span><span class="n">n_replicas</span><span class="p">))</span>
        
        <span class="n">traj_distances</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">compute_distances</span><span class="p">(</span>
            <span class="n">rep_traj</span><span class="p">,</span><span class="n">native_contact_list</span><span class="p">,</span><span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">opt</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># This produces a [nframe x len(native_contacts)] array</span>
  
        <span class="c1"># Compute Boolean matrix for whether or not a distance is native</span>
        <span class="n">native_contact_matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">traj_distances</span><span class="o">&lt;</span><span class="p">(</span><span class="n">native_contact_cutoff_ratio</span><span class="o">*</span><span class="n">native_contact_distances</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">nc_unit</span><span class="p">)))</span>

        <span class="n">number_native_interactions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">native_contact_matrix</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">Q</span><span class="p">[:,</span><span class="n">rep</span><span class="p">]</span> <span class="o">=</span> <span class="n">number_native_interactions</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">native_contact_distances</span><span class="p">)</span>
        <span class="n">Q_avg</span><span class="p">[</span><span class="n">rep</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span><span class="n">rep</span><span class="p">])</span>
        <span class="c1"># Compute standard error:</span>
        <span class="n">Q_stderr</span><span class="p">[</span><span class="n">rep</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span><span class="n">rep</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span><span class="n">rep</span><span class="p">]))</span>
    
    <span class="c1"># Determine the decorrelation time of native contact fraction timeseries data:</span>
    <span class="c1"># Note: if these are replica trajectories, we will get a folding rate</span>
    <span class="c1"># If these are state trajectories, we will get decorrelation time for constant state</span>
    <span class="n">max_sample_spacing</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">subsample_indices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_replicas</span><span class="p">):</span>
        <span class="n">subsample_indices</span><span class="p">[</span><span class="n">rep</span><span class="p">]</span> <span class="o">=</span> <span class="n">timeseries</span><span class="o">.</span><span class="n">subsampleCorrelatedData</span><span class="p">(</span>
            <span class="n">Q</span><span class="p">[:,</span><span class="n">rep</span><span class="p">],</span>
            <span class="n">conservative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">subsample_indices</span><span class="p">[</span><span class="n">rep</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">subsample_indices</span><span class="p">[</span><span class="n">rep</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_sample_spacing</span><span class="p">:</span>
            <span class="n">max_sample_spacing</span> <span class="o">=</span> <span class="p">(</span><span class="n">subsample_indices</span><span class="p">[</span><span class="n">rep</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">subsample_indices</span><span class="p">[</span><span class="n">rep</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="n">decorrelation_spacing</span> <span class="o">=</span> <span class="n">max_sample_spacing</span>
        
    <span class="k">return</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Q_avg</span><span class="p">,</span> <span class="n">Q_stderr</span><span class="p">,</span> <span class="n">decorrelation_spacing</span></div>

<div class="viewcode-block" id="optimize_Q"><a class="viewcode-back" href="../../../index.html#cg_openmm.parameters.secondary_structure.optimize_Q">[docs]</a><span class="k">def</span> <span class="nf">optimize_Q</span><span class="p">(</span><span class="n">cgmodel</span><span class="p">,</span> <span class="n">native_structure</span><span class="p">,</span> <span class="n">ensemble</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a coarse grained model and a native structure as input</span>

<span class="sd">        :param cgmodel: CGModel() class object</span>
<span class="sd">        :type cgmodel: class</span>

<span class="sd">        :param native_structure: Positions for the native structure.</span>
<span class="sd">        :type native_structure: np.array( float * unit.angstrom ( num_particles x 3 ) )</span>

<span class="sd">        :param ensemble: A list of poses that will be used to optimize the cutoff distance for defining native contacts</span>
<span class="sd">        :type ensemble: List(positions(np.array(float*simtk.unit (shape = num_beads x 3))))</span>

<span class="sd">        :returns:</span>
<span class="sd">          - native_structure_contact_distance_cutoff ( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) - The ideal distance below which two nonbonded, interacting particles should be defined as a &quot;native contact&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="n">cutoff_list</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.95</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">*</span> <span class="n">cgmodel</span><span class="o">.</span><span class="n">get_sigma</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)]</span>

    <span class="n">cutoff_Q_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cutoff</span> <span class="ow">in</span> <span class="n">cutoff_list</span><span class="p">:</span>
        <span class="n">Q_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pose</span> <span class="ow">in</span> <span class="n">ensemble</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">fraction_native_contacts</span><span class="p">(</span>
                <span class="n">cgmodel</span><span class="p">,</span> <span class="n">pose</span><span class="p">,</span> <span class="n">native_structure</span><span class="p">,</span> <span class="n">native_structure_contact_distance_cutoff</span><span class="o">=</span><span class="n">cutoff</span>
            <span class="p">)</span>
            <span class="n">Q_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>

        <span class="n">mean_Q</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">Q_list</span><span class="p">)</span>
        <span class="n">cutoff_Q_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mean_Q</span><span class="p">)</span>

    <span class="n">cutoff_Q_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">cutoff_Q_list</span><span class="p">))</span>

    <span class="n">native_structure_contact_distance_cutoff</span> <span class="o">=</span> <span class="n">cutoff_Q_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">cutoff_Q_list</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">native_structure_contact_distance_cutoff</span></div>
    

<div class="viewcode-block" id="plot_native_contact_fraction"><a class="viewcode-back" href="../../../index.html#cg_openmm.parameters.secondary_structure.plot_native_contact_fraction">[docs]</a><span class="k">def</span> <span class="nf">plot_native_contact_fraction</span><span class="p">(</span><span class="n">temperature_list</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">Q_uncertainty</span><span class="p">,</span><span class="n">plotfile</span><span class="o">=</span><span class="s2">&quot;Q_vs_T.pdf&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of temperatures and corresponding native contact fractions, plot Q vs T.</span>

<span class="sd">    :param temperature_list: List of temperatures that will be used to define different replicas (thermodynamics states), default = None</span>
<span class="sd">    :type temperature_list: List( `SIMTK &lt;https://simtk.org/&gt;`_ `Unit() &lt;http://docs.openmm.org/7.1.0/api-python/generated/simtk.unit.unit.Unit.html&gt;`_ * number_replicas )</span>

<span class="sd">    :param Q: native contact fraction for a given temperature</span>
<span class="sd">    :type Q: np.array(float * len(temperature_list))</span>
<span class="sd">    </span>
<span class="sd">    :param Q_uncertainty: uncertainty associated with Q</span>
<span class="sd">    :type Q_uncertainty: np.array(float * len(temperature_list))</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">temperature_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">temperature_list</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temperature_list</span><span class="p">)):</span>
        <span class="n">temperature_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperature_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">kelvin</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span>
        <span class="n">temperature_array</span><span class="p">,</span>
        <span class="n">Q</span><span class="p">,</span>
        <span class="n">Q_uncertainty</span><span class="p">,</span>
        <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o-&#39;</span><span class="p">,</span>
        <span class="n">fillstyle</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
        <span class="n">capsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;T (K)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Native contact fraction&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">plotfile</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>
    
    
<div class="viewcode-block" id="plot_native_contact_timeseries"><a class="viewcode-back" href="../../../index.html#cg_openmm.parameters.secondary_structure.plot_native_contact_timeseries">[docs]</a><span class="k">def</span> <span class="nf">plot_native_contact_timeseries</span><span class="p">(</span>
    <span class="n">Q</span><span class="p">,</span>
    <span class="n">time_interval</span><span class="o">=</span><span class="mf">1.0</span><span class="o">*</span><span class="n">unit</span><span class="o">.</span><span class="n">picosecond</span><span class="p">,</span>
    <span class="n">frame_begin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">plot_per_page</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">plotfile</span><span class="o">=</span><span class="s2">&quot;Q_vs_time.pdf&quot;</span><span class="p">,</span>
    <span class="n">figure_title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given average native contact fractions timeseries for each replica or state, plot Q vs time.</span>

<span class="sd">    :param Q: native contact fraction for a given temperature</span>
<span class="sd">    :type Q: np.array(float * nframes x len(temperature_list))</span>
<span class="sd">    </span>
<span class="sd">    :param time_interval: interval between energy exchanges.</span>
<span class="sd">    :type time_interval: `SIMTK &lt;https://simtk.org/&gt;`_ `Unit() &lt;http://docs.openmm.org/7.1.0/api-python/generated/simtk.unit.unit.Unit.html&gt;`_</span>

<span class="sd">    :param frame_begin: index of first frame defining the range of samples to use as a production period (default=0)</span>
<span class="sd">    :type frame_begin: int</span>
<span class="sd">    </span>
<span class="sd">    :param plot_per_page: number of subplots per pdf page (default=3)</span>
<span class="sd">    :type plot_per_page: int</span>

<span class="sd">    :param plotfile: The pathname of the output file for plotting results, default = &quot;replica_exchange_state_transitions.png&quot;</span>
<span class="sd">    :type plotfile: str</span>
<span class="sd">    </span>
<span class="sd">    :param figure_title: title of overall plot</span>
<span class="sd">    :type figure_title: str</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="n">time_shift</span><span class="o">=</span><span class="n">frame_begin</span><span class="o">*</span><span class="n">time_interval</span>    
        
    <span class="n">simulation_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">step</span> <span class="o">*</span> <span class="n">time_interval</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">picosecond</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span>
        <span class="p">]</span>
    <span class="p">)</span>
    
    <span class="n">simulation_times</span> <span class="o">+=</span> <span class="n">time_shift</span><span class="o">.</span><span class="n">value_in_unit</span><span class="p">(</span><span class="n">unit</span><span class="o">.</span><span class="n">picosecond</span><span class="p">)</span>
    
    <span class="c1"># Determine number of data series:</span>
    <span class="n">nseries</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="n">nrow</span> <span class="o">=</span> <span class="n">plot_per_page</span>
    
    <span class="c1"># Number of pdf pages</span>
    <span class="n">npage</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nseries</span><span class="o">/</span><span class="n">nrow</span><span class="p">))</span>
    
    <span class="n">xlabel</span><span class="o">=</span><span class="s2">&quot;Simulation time (ps)&quot;</span>
    <span class="n">ylabel</span><span class="o">=</span><span class="s2">&quot;Q&quot;</span>
    
    <span class="k">with</span> <span class="n">PdfPages</span><span class="p">(</span><span class="n">plotfile</span><span class="p">)</span> <span class="k">as</span> <span class="n">pdf</span><span class="p">:</span>
        <span class="n">plotted_per_page</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">page_num</span><span class="o">=</span><span class="mi">1</span>
        <span class="n">figure</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">8.5</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nseries</span><span class="p">):</span>
            <span class="n">plotted_per_page</span> <span class="o">+=</span> <span class="mi">1</span>
            
            <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">plotted_per_page</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">simulation_times</span><span class="p">,</span>
                <span class="n">Q</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span>
                <span class="s1">&#39;-&#39;</span><span class="p">,</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>
            
            
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
                    
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;replica </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">plotted_per_page</span> <span class="o">&gt;=</span> <span class="n">nrow</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="n">nseries</span><span class="p">):</span>
                <span class="c1"># Save and close previous page</span>
                
                <span class="c1"># Use xlabels for bottom row only:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
                
                <span class="c1"># Adjust subplot spacing</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">figure_title</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">figure_title</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">page_num</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span><span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
            
                <span class="n">pdf</span><span class="o">.</span><span class="n">savefig</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">plotted_per_page</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">page_num</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">!=</span> <span class="n">nseries</span><span class="p">:</span>
                    <span class="n">figure</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">8.5</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span></div>
        
   
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Shirts Group. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.3

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>