

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cg_openmm.cg_model.cgmodel &mdash; cg_openmm  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> cg_openmm
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">CGModel class:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../cgmodel_class.html">CGModel class</a></li>
</ul>
<p class="caption"><span class="caption-text">API documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">cg_openmm</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>cg_openmm.cg_model.cgmodel</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for cg_openmm.cg_model.cgmodel</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">simtk.unit</span> <span class="k">as</span> <span class="nn">unit</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">cg_openmm.utilities.random_builder</span> <span class="kn">import</span> <span class="n">get_random_positions</span>
<span class="kn">from</span> <span class="nn">cg_openmm.build.cg_build</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">cg_openmm.utilities.iotools</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">pickle</span>


<div class="viewcode-block" id="CGModel"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel">[docs]</a><span class="k">class</span> <span class="nc">CGModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Build a coarse-grained model class object.</span>

<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; from foldamers.cg_model.cgmodel import CGModel</span>
<span class="sd">        &gt;&gt;&gt; cgmodel = CGModel()</span>

<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; from foldamers.cg_model.cgmodel import CGModel</span>
<span class="sd">        &gt;&gt;&gt; from simtk import unit</span>
<span class="sd">        &gt;&gt;&gt; bond_length = 7.5 * unit.angstrom</span>
<span class="sd">        &gt;&gt;&gt; bond_lengths = {&#39;bb_bb_bond_length&#39;: bond_length,&#39;bb_sc_bond_length&#39;: bond_length,&#39;sc_sc_bond_length&#39;: bond_length}</span>
<span class="sd">        &gt;&gt;&gt; constrain_bonds = False</span>
<span class="sd">        &gt;&gt;&gt; cgmodel = CGModel(bond_lengths=bond_lengths,constrain_bonds=constrain_bonds)</span>

<span class="sd">        :Example:</span>

<span class="sd">        &gt;&gt;&gt; from foldamers.cg_model.cgmodel import CGModel</span>
<span class="sd">        &gt;&gt;&gt; from simtk import unit</span>
<span class="sd">        &gt;&gt;&gt; backbone_length=1</span>
<span class="sd">        &gt;&gt;&gt; sidechain_length=1</span>
<span class="sd">        &gt;&gt;&gt; sidechain_positions=0</span>
<span class="sd">        &gt;&gt;&gt; bond_length = 7.5 * unit.angstrom</span>
<span class="sd">        &gt;&gt;&gt; sigma = 2.0 * bond_length</span>
<span class="sd">        &gt;&gt;&gt; epsilon = 0.2 * unit.kilocalorie_per_mole</span>
<span class="sd">        &gt;&gt;&gt; sigmas = {&#39;bb_bb_sigma&#39;: sigma,&#39;sc_sc_sigma&#39;: sigma}</span>
<span class="sd">        &gt;&gt;&gt; epsilons = {&#39;bb_bb_eps&#39;: epsilon,&#39;bb_sc_eps&#39;: epsilon,&#39;sc_sc_eps&#39;: epsilon}</span>
<span class="sd">        &gt;&gt;&gt; A = {&#39;monomer_name&#39;: &quot;A&quot;, &#39;backbone_length&#39;: backbone_length, &#39;sidechain_length&#39;: sidechain_length, &#39;sidechain_positions&#39;: sidechain_positions, &#39;num_beads&#39;: num_beads, &#39;bond_lengths&#39;: bond_lengths, &#39;epsilons&#39;: epsilons, &#39;sigmas&#39;: sigmas}</span>
<span class="sd">        &gt;&gt;&gt; B = {&#39;monomer_name&#39;: &quot;B&quot;, &#39;backbone_length&#39;: backbone_length, &#39;sidechain_length&#39;: sidechain_length, &#39;sidechain_positions&#39;: sidechain_positions, &#39;num_beads&#39;: num_beads, &#39;bond_lengths&#39;: bond_lengths, &#39;epsilons&#39;: epsilons, &#39;sigmas&#39;: sigmas}</span>
<span class="sd">        &gt;&gt;&gt; monomer_types = [A,B]</span>
<span class="sd">        &gt;&gt;&gt; sequence = [A,A,A,B,A,A,A,B,A,A,A,B]</span>
<span class="sd">        &gt;&gt;&gt; cgmodel = CGModel(monomer_types=monomer_types,sequence=sequence)</span>

<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">particle_type_list</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">charges</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">bond_lengths</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">bond_force_constants</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">bond_angle_force_constants</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">torsion_force_constants</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">torsion_periodicities</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">equil_bond_angles</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">equil_torsion_angles</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">constrain_bonds</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_bond_forces</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">include_nonbonded_forces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_bond_angle_forces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_torsion_forces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">exclusions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">rosetta_functional_form</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">check_energy_conservation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">use_structure_library</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">random_positions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">system</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">topology</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">simulation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">monomer_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sequence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Initialize definitions for all of the properties of a coarse-grained model</span>

<span class="sd">          ..warning:: A large number of default definitions are applied when constructing the CGModel object, in an effort to make intiation of the class easier.  Please review these defaults (listed below) carefully before using this class.</span>

<span class="sd">          :param positions: Positions for the particles in the coarse-grained model, default = None</span>
<span class="sd">          :type positions: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ( np.array( [cgmodel.num_beads,3] ), simtk.unit )</span>

<span class="sd">          :param particle list: list of all particle types, default = None</span>
<span class="sd">          :type particle: list </span>

<span class="sd">          :param sigmas: Non-bonded bead Lennard-Jones equilibrium interaction distances, default = None</span>
<span class="sd">          :type sigmas: dict( &#39;bb_bb_sigma&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ,&#39;bb_sc_sigma&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ,&#39;sc_sc_sigma&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ )</span>

<span class="sd">          :param epsilons: Non-bonded Lennard-Jones equilibrium interaction strengths, default = None</span>
<span class="sd">          :type epsilons: dict( &#39;bb_bb_eps&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ,&#39;bb_sc_eps&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ,&#39;sc_sc_eps&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ )</span>

<span class="sd">          :param bond_lengths: Bond lengths for all bonds, default = None</span>
<span class="sd">          :type bond_lengths: dict( &#39;bb_bb_bond_length&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ,&#39;bb_sc_bond_length&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ,&#39;sc_sc_bond_length&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ )</span>

<span class="sd">          :param bond_angle_force_constants: Bond angle force constants for all bond types, default = None</span>
<span class="sd">          :type bond_angle_force_constants: dict( &#39;bb_bb__bb_angle_k&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ,&#39;bb_bb_sc_angle_k&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ , &#39;bb_sc_sc_angle_k&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ , &#39;sc_sc_sc_angle_k&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ , &#39;sc_bb_sc_angle_k&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ , &#39;sc_sc_bb_angle_k&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ )</span>

<span class="sd">          :param bond_force_constants: Bond force constants for all bond types, default = None</span>
<span class="sd">          :type bond_force_constants: dict( &#39;bb_bb_bond_k&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ,&#39;bb_sc_bond_k&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ , &#39;sc_sc_bond_k&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ )</span>

<span class="sd">          :param equil_bond_angles: Equilibrium bond angle for all bond angle types, default = None</span>
<span class="sd">          :type equil_bond_angles: dict(&#39;bb_bb_bb_angle_0&#39;: float,&#39;bb_bb_sc_angle_0&#39;: float,&#39;bb_sc_sc_angle_0&#39;: float,&#39;sc_sc_sc_angle_0&#39;: float, &#39;sc_bb_sc_angle_0&#39;: float,&#39;sc_sc_bb_angle_0&#39;: float )</span>

<span class="sd">          :param torsion_force_constants: Torsion force constants for all unique torsion definitions, default = None</span>
<span class="sd">          :type torsion_force_constants: dict( &#39;bb_bb_bb_bb_torsion_k&#39;: float,&#39;bb_bb_bb_sc_torsion_k&#39;: float,&#39;bb_bb_sc_sc_torsion_k&#39;: float, &#39;bb_sc_sc_sc_torsion_k&#39;: float, &#39;sc_bb_bb_sc_torsion_k&#39;: float, &#39;bb_sc_sc_bb_torsion_k&#39;: float, &#39;sc_sc_sc_sc_torsion_k&#39;: float,  &#39;sc_bb_bb_bb_torsion_k&#39;: float )</span>

<span class="sd">          :param equil_torsion_angles: Equilibrium torsion angle for all unique torsion angle definitions, default = 0</span>
<span class="sd">          :type equil_torsion_angles: dict( &#39;bb_bb_bb_bb_torsion_0&#39;: float,&#39;bb_bb_bb_sc_torsion_0&#39;: float,&#39;bb_bb_sc_sc_torsion_0&#39;: float, &#39;bb_sc_sc_sc_torsion_0&#39;: float, &#39;sc_bb_bb_sc_torsion_0&#39;: float, &#39;bb_sc_sc_bb_torsion_0&#39;: float, &#39;sc_sc_sc_sc_torsion_0&#39;: float, &#39;sc_bb_bb_bb_torsion_0&#39;: float )</span>

<span class="sd">          :param charges: Charges for all particles, default = None</span>
<span class="sd">          :type charges: dict( &#39;backbone_bead_charges&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ,&#39;sidechain_bead_charges&#39;: `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ )</span>

<span class="sd">          :param system: OpenMM System() object, which stores the forces for the coarse grained model, default = None</span>
<span class="sd">          :type system: `System() &lt;https://simtk.org/api_docs/openmm/api4_1/python/classsimtk_1_1openmm_1_1openmm_1_1System.html&gt;`_</span>

<span class="sd">          :param topology: OpenMM Topology() object, which stores bonds, angles, and other structural attributes of the coarse-grained model, default = None</span>
<span class="sd">          :type topology: `Topology() &lt;https://simtk.org/api_docs/openmm/api4_1/python/classsimtk_1_1openmm_1_1app_1_1topology_1_1Topology.html&gt;`_</span>

<span class="sd">          :param constrain_bonds: Logical variable determining whether bond constraints are applied during a simulation of the energy for the system, default = True</span>
<span class="sd">          :type constrain_bonds: Logical</span>

<span class="sd">          :param include_bond_forces: Include contributions from bond potentials when calculating the potential energy, default = False</span>
<span class="sd">          :type include_bond_forces: Logical</span>

<span class="sd">          :param include_nonbonded_forces: Include contributions from nonbonded interactions when calculating the potential energy, default = True</span>
<span class="sd">          :type include_nonbonded_forces: Logical</span>

<span class="sd">          :param include_bond_angle_forces: Include contributions from bond angle forces when calculating the potential energy, default = True</span>
<span class="sd">          :type include_bond_angle_forces: Logical</span>

<span class="sd">          :param include_torsion_forces: Include contributions from torsions when calculating the potential energy, default = True</span>
<span class="sd">          :type include_torsion_forces: Logical</span>

<span class="sd">          :param check_energy_conservation: Flag designating whether or not to perform a test OpenMM simulation with this coarse-grained model.</span>
<span class="sd">          :type check_energy_conservation: Logical</span>

<span class="sd">          :param use_structure_library: Flag designating whether or not to use a structure from the foldamers ensemble as the initial positions for the particles in the coarse-grained model, default = False</span>
<span class="sd">          :type use_structure_library: Logical</span>

<span class="sd">          :param monomer_types: A list of dictionary objects containing the properties for unique monomer types (used to construct a heteropolymeric coarse-grained model, default = None</span>
<span class="sd">          :type monomer_types: List( dict( &#39;monomer_name&#39;: str, &#39;backbone_length&#39;: int, &#39;sidechain_length&#39;: int, &#39;sidechain_positions&#39;: List( int ), &#39;num_beads&#39;: int, &#39;bond_lengths&#39;: List( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ), &#39;epsilons&#39;: List( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ), &#39;sigmas&#39;: List( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) ) )</span>

<span class="sd">          :param backbone_lengths: List of the number of beads in the backbone for unique monomer types within the coarse grained model, default = 1</span>
<span class="sd">          :type backbone_lengths: int</span>

<span class="sd">          :param sidechain_lengths: List of the number of beads in the sidechain for unique monomer types within the coarse grained model, default = 1</span>
<span class="sd">          :type sidechain_lengths: int</span>

<span class="sd">          :param sidechain_positions: List of the indices of backbone beads upon which we will place sidechains, default = [0] (add a sidechain to the first backbone bead in each monomer)</span>
<span class="sd">          :type sidechain_positions: List( integer )</span>


<span class="sd">          :param sequence: The sequence from which to build a heteropolymer.  Defined using a list of &#39;monomer_types&#39;, each of which contains the properties for that monomer, default = None (Homopolymer)</span>
<span class="sd">          :type sequence: List( dict( &#39;monomer_name&#39;: str, &#39;backbone_length&#39;: int, &#39;sidechain_length&#39;: int, &#39;sidechain_positions&#39;: List( int ), &#39;num_beads&#39;: int, &#39;bond_lengths&#39;: List( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ), &#39;epsilons&#39;: List( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ), &#39;sigmas&#39;: List( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) ) )</span>

<span class="sd">          :param random_positions: Flag designating whether or not to generate a set of random coordinates for the coarse-grained model, default = None</span>


<span class="sd">          &quot;&quot;&quot;</span>

        <span class="c1"># define some default units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_mass</span> <span class="o">=</span> <span class="mi">72</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">amu</span>  <span class="c1"># from martini 3.0 C1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_length</span> <span class="o">=</span> <span class="mf">0.47</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">nanometers</span>  <span class="c1"># from martini 3.0 C1 particle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_angle</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">degrees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_energyscale</span> <span class="o">=</span> <span class="mf">3.5</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">kilojoule_per_mole</span>  <span class="c1"># from martini 3.0 C1 particle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_bond_force_constant</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">1250.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">kilojoule_per_mole</span> <span class="o">/</span> <span class="n">unit</span><span class="o">.</span><span class="n">nanometer</span> <span class="o">/</span> <span class="n">unit</span><span class="o">.</span><span class="n">nanometer</span>
        <span class="p">)</span>  <span class="c1"># from martini 3.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_torsion_force_constant</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">kilojoule_per_mole</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_bond_angle_force_constant</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">kilojoule_per_mole</span> <span class="o">/</span> <span class="n">unit</span><span class="o">.</span><span class="n">radian</span> <span class="o">/</span> <span class="n">unit</span><span class="o">.</span><span class="n">radian</span>
        <span class="p">)</span>  <span class="c1"># from martini 3.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_charge</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">unit</span><span class="o">.</span><span class="n">elementary_charge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_periodicity</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize user-defined input.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Assign forces based upon input flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rosetta_functional_form</span> <span class="o">=</span> <span class="n">rosetta_functional_form</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_bond_forces</span> <span class="o">=</span> <span class="n">include_bond_forces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constrain_bonds</span> <span class="o">=</span> <span class="n">constrain_bonds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_bond_angle_forces</span> <span class="o">=</span> <span class="n">include_bond_angle_forces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_nonbonded_forces</span> <span class="o">=</span> <span class="n">include_nonbonded_forces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span> <span class="o">=</span> <span class="n">exclusions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_torsion_forces</span> <span class="o">=</span> <span class="n">include_torsion_forces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_energy_conservation</span> <span class="o">=</span> <span class="n">check_energy_conservation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monomer_types</span> <span class="o">=</span> <span class="n">monomer_types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bond_lengths</span> <span class="o">=</span> <span class="n">bond_lengths</span>

        <span class="c1"># fill in defaults in particle list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_type_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_particle_type_list</span><span class="p">(</span><span class="n">particle_type_list</span><span class="p">)</span>

        <span class="c1"># Build a polymer with these model settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_polymer</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>

        <span class="c1"># Assign particle properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_types</span> <span class="o">=</span> <span class="n">add_new_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Assign bonded force properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bond_force_constants</span> <span class="o">=</span> <span class="n">bond_force_constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bond_angle_force_constants</span> <span class="o">=</span> <span class="n">bond_angle_force_constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equil_bond_angles</span> <span class="o">=</span> <span class="n">equil_bond_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">torsion_force_constants</span> <span class="o">=</span> <span class="n">torsion_force_constants</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">torsion_periodicities</span> <span class="o">=</span> <span class="n">torsion_periodicities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equil_torsion_angles</span> <span class="o">=</span> <span class="n">equil_torsion_angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_bonded_forces</span><span class="p">()</span>

        <span class="c1"># Assign positions</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">random_positions</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">get_random_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_library</span><span class="o">=</span><span class="n">use_structure_library</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">positions</span>

        <span class="c1"># Define storage for simulation objects from OpenMM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simulation</span> <span class="o">=</span> <span class="n">simulation</span>

        <span class="c1"># Define OpenMM topology</span>
        <span class="k">if</span> <span class="n">topology</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">positions</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">build_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">use_pdbfile</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">=</span> <span class="n">topology</span>

        <span class="c1"># Define OpenMM system</span>
        <span class="k">if</span> <span class="n">system</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">system</span> <span class="o">=</span> <span class="n">build_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rosetta_functional_form</span><span class="o">=</span><span class="n">rosetta_functional_form</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">system</span> <span class="o">=</span> <span class="n">system</span>

<div class="viewcode-block" id="CGModel.export"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.export">[docs]</a>    <span class="k">def</span> <span class="nf">export</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        export to a pickle file.</span>

<span class="sd">        :param filename: filename for exporting the cgmodel</span>
<span class="sd">        :type CGModel: str</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pickle_out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickle_out</span><span class="p">)</span>
        <span class="n">pickle_out</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_validate_bonded_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># check the names that are included in the dictionaries to make sure</span>
        <span class="c1"># there are no mispellings.</span>

        <span class="c1"># dictionary of the force attributes</span>

        <span class="c1"># for each force attribute, which appears in the dictionary defining the forces,</span>
        <span class="c1"># define certain properties;</span>
        <span class="c1">#     &quot;default name&quot; : the name to look for default definitions of those nonboded forces.</span>
        <span class="c1">#     &quot;default value&quot; : the value to store if the default is not given,</span>
        <span class="c1">#     &quot;suffix&quot; : the suffix that those forces should have</span>
        <span class="c1"># We are trying to minimize the number of places adding new forces changes the code,</span>
        <span class="c1"># and this should help with that.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bonded_force_attributes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;bond_lengths&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;default_name&quot;</span><span class="p">:</span> <span class="s2">&quot;default_bond_length&quot;</span><span class="p">,</span>
                <span class="s2">&quot;default_value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_length</span><span class="p">,</span>
                <span class="s2">&quot;suffix&quot;</span><span class="p">:</span> <span class="s2">&quot;bond_length&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;bond_force_constants&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;default_name&quot;</span><span class="p">:</span> <span class="s2">&quot;default_bond_force_constant&quot;</span><span class="p">,</span>
                <span class="s2">&quot;default_value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_bond_force_constant</span><span class="p">,</span>
                <span class="s2">&quot;suffix&quot;</span><span class="p">:</span> <span class="s2">&quot;bond_force_constant&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;equil_bond_angles&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;default_name&quot;</span><span class="p">:</span> <span class="s2">&quot;default_equil_bond_angle&quot;</span><span class="p">,</span>
                <span class="s2">&quot;default_value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_angle</span><span class="p">,</span>
                <span class="s2">&quot;suffix&quot;</span><span class="p">:</span> <span class="s2">&quot;equil_bond_angle&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;bond_angle_force_constants&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;default_name&quot;</span><span class="p">:</span> <span class="s2">&quot;default_bond_angle_force_constant&quot;</span><span class="p">,</span>
                <span class="s2">&quot;default_value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_bond_angle_force_constant</span><span class="p">,</span>
                <span class="s2">&quot;suffix&quot;</span><span class="p">:</span> <span class="s2">&quot;bond_angle_force_constant&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;equil_torsion_angles&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;default_name&quot;</span><span class="p">:</span> <span class="s2">&quot;default_equil_torsion_angle&quot;</span><span class="p">,</span>
                <span class="s2">&quot;default_value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_angle</span><span class="p">,</span>
                <span class="s2">&quot;suffix&quot;</span><span class="p">:</span> <span class="s2">&quot;equil_torsion_angle&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;torsion_force_constants&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;default_name&quot;</span><span class="p">:</span> <span class="s2">&quot;default_torsion_force_constant&quot;</span><span class="p">,</span>
                <span class="s2">&quot;default_value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_torsion_force_constant</span><span class="p">,</span>
                <span class="s2">&quot;suffix&quot;</span><span class="p">:</span> <span class="s2">&quot;torsion_force_constant&quot;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s2">&quot;torsion_periodicities&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;default_name&quot;</span><span class="p">:</span> <span class="s2">&quot;default_torsion_periodicity&quot;</span><span class="p">,</span>
                <span class="s2">&quot;default_value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_periodicity</span><span class="p">,</span>
                <span class="s2">&quot;suffix&quot;</span><span class="p">:</span> <span class="s2">&quot;torsion_periodicity&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>

        <span class="c1"># make sure all the property values are internally consistent</span>
        <span class="k">for</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonded_force_attributes</span><span class="p">:</span>
            <span class="c1"># for the bonded force attributes</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">):</span>
                <span class="n">properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonded_force_attributes</span><span class="p">[</span><span class="n">attribute</span><span class="p">]</span>
                <span class="n">default_name</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;default_name&quot;</span><span class="p">]</span>
                <span class="c1"># if the default name hasn&#39;t been defined for this model</span>
                <span class="k">if</span> <span class="n">default_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">):</span>
                    <span class="n">default_value</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;default_value&quot;</span><span class="p">]</span>
                    <span class="c1"># set it to the the default for the program.</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Warning: No </span><span class="si">{</span><span class="n">default_name</span><span class="si">}</span><span class="s2">: setting to </span><span class="si">{</span><span class="n">default_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">parameter_dict</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute</span><span class="p">)</span>
                    <span class="c1"># actually add the default force to the dictionary.</span>
                    <span class="n">default_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">default_name</span> <span class="p">:</span> <span class="n">default_value</span><span class="p">}</span>
                    <span class="n">parameter_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">default_dict</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">attribute</span><span class="p">,</span><span class="n">parameter_dict</span><span class="p">)</span>
                <span class="n">default_suffix</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;suffix&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">force</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">):</span>
                    <span class="c1"># make sure all forces have the corresponding suffix.</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">default_suffix</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">force</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Warning: force term &#39;</span><span class="si">{</span><span class="n">force</span><span class="si">}</span><span class="s2">&#39; does not have proper suffix of </span><span class="si">{</span><span class="n">default_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">exit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_validate_particle_type_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_type_list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        parameters: list of particle types</span>

<span class="sd">        Check each of the defined particles to make sure it&#39;s properly defined</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">particle_type_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">particle_type_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># we need a default particle.  Call it a.</span>
            <span class="n">default_particle_type_name</span> <span class="o">=</span> <span class="s2">&quot;a&quot;</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No particles defined: creating a default particle named: </span><span class="si">{</span><span class="n">default_particle_type_name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">particle_type_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">particle</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;particle_type_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_particle_type_name</span>
            <span class="n">particle_type_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">particle</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">particle</span> <span class="ow">in</span> <span class="n">particle_type_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;particle_type_name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">particle</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Particle has no attribute &quot;particle_type_name&quot;: Exiting now&#39;</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;particle_type_name&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;sigma&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">particle</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;sigma not defined for particle type </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> using default sigma: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">default_length</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_length</span>
            <span class="k">if</span> <span class="s2">&quot;mass&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">particle</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;mass not defined for particle type </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> using default mass: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">default_mass</span><span class="si">:}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_mass</span>
            <span class="k">if</span> <span class="s2">&quot;epsilon&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">particle</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;epsilon not defined for particle type </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> using default epsilon: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">default_energyscale</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;epsilon&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_energyscale</span>
            <span class="k">if</span> <span class="s2">&quot;charge&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">particle</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;charge not defined for particle type </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> using default charge: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">default_charge</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;charge&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_charge</span>

        <span class="k">return</span> <span class="n">particle_type_list</span>

<div class="viewcode-block" id="CGModel.build_polymer"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.build_polymer">[docs]</a>    <span class="k">def</span> <span class="nf">build_polymer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Used to build a polymer, or reset the properties for a polymer after parameters such as the polymer_length or sequence have been modified.</span>
<span class="sd">          &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polymer_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span> <span class="o">=</span> <span class="n">sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_monomer_types</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_beads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_beads</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_particle_list</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_bond_forces</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">constrain_bonds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bond_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bond_list</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bond_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bond_angle_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bond_angle_list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">torsion_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_torsion_list</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclusions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nonbonded_exclusion_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nonbonded_exclusion_list</span><span class="p">(</span>
                <span class="n">rosetta_functional_form</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rosetta_functional_form</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nonbonded_exclusion_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nonbonded_interaction_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nonbonded_interaction_list</span><span class="p">()</span></div>

<div class="viewcode-block" id="CGModel.process_monomer_types"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.process_monomer_types">[docs]</a>    <span class="k">def</span> <span class="nf">process_monomer_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Clean up a list of &#39;monomer_types&#39; for all unique monomers.</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">monomer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">monomer_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;monomer_name&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: monomers must have names!&quot;</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>  <span class="c1"># figure out how to handle with exceptions.</span>

            <span class="n">mn</span> <span class="o">=</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;monomer_name&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;particle_sequence&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">monomer</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: monomer </span><span class="si">{</span><span class="n">mm</span><span class="si">}</span><span class="s2"> must have a list of particle types!&quot;</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>  <span class="c1"># figure out how to handle with exceptions.</span>

            <span class="k">if</span> <span class="s2">&quot;bond_list&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">monomer</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;bond_list&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;particle_sequence&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Error: monomer </span><span class="si">{</span><span class="n">mm</span><span class="si">}</span><span class="s2"> is has more than one particle, so it must have a bond list of pairs of bonded particles!&quot;</span>
                <span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>  <span class="c1"># figure out how to handle with exceptions.</span>

            <span class="k">if</span> <span class="s2">&quot;start&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">monomer</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Warning: no starting particle is indicated for monomer </span><span class="si">{</span><span class="n">mm</span><span class="si">}</span><span class="s2">: I&#39;m assuming it&#39;s the first particle in the sequence.&quot;</span>
                <span class="p">)</span>
                <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="s2">&quot;end&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">monomer</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Warning: no ending particle is indicated for monomer </span><span class="si">{</span><span class="n">mm</span><span class="si">}</span><span class="s2">: I&#39;m assuming it&#39;s the last one in the sequence.&quot;</span>
                <span class="p">)</span>
                <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;particle_sequence&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;num_beads&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;particle_sequence&quot;</span><span class="p">])</span>

            <span class="c1"># double check the bonds are consistent with the particles:</span>

            <span class="c1"># are any of the bond particles too large?</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;bond_list&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;num_beads&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;num_beads&quot;</span><span class="p">]:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Error: monomer </span><span class="si">{</span><span class="n">mn</span><span class="si">}</span><span class="s2"> has a bond [</span><span class="si">{</span><span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">] with a particle index too high (&gt;=</span><span class="si">{</span><span class="n">monomer</span><span class="p">[</span><span class="s1">&#39;num_beads&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
                    <span class="n">exit</span><span class="p">()</span>  <span class="c1"># figure out how to handle with exceptions.</span>

            <span class="c1"># are there any particles with no bonds?</span>
            <span class="n">unbonded</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;num_beads&quot;</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;bond_list&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">unbonded</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">unbonded</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">unbonded</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: particle </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> in monomer </span><span class="si">{</span><span class="n">mm</span><span class="si">}</span><span class="s2"> has no bonds.&quot;</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span></div>

<div class="viewcode-block" id="CGModel.get_num_beads"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_num_beads">[docs]</a>    <span class="k">def</span> <span class="nf">get_num_beads</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Calculate the number of beads in a coarse-grained model class object</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :returns: </span>
<span class="sd">            - num_beads (int) - The total number of beads in the coarse-grained model</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="n">num_beads</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">monomer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">:</span>
            <span class="n">num_beads</span> <span class="o">=</span> <span class="n">num_beads</span> <span class="o">+</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;num_beads&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">num_beads</span></div>

<div class="viewcode-block" id="CGModel.create_particle_list"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.create_particle_list">[docs]</a>    <span class="k">def</span> <span class="nf">create_particle_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a list of particles, where the indices correspond to those in the system/topology.</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :returns: </span>
<span class="sd">            - particle_list ( List( str ) ) - A list of unique particles in the coarse-grained model</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="n">particle_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">particle_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">monomer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">):</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;particle_sequence&quot;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bead</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
                <span class="n">particle</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bead</span>
                <span class="c1"># will need to come up with a better naming scheme than X</span>
                <span class="c1"># X for backbones and A for monomers</span>
                <span class="k">if</span> <span class="s2">&quot;particle_type_name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bead</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&#39;particle_type_name&#39; not defined, cannot contiue&quot;</span><span class="p">)</span>
                    <span class="n">exit</span><span class="p">()</span>
                <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bead</span><span class="p">[</span><span class="s1">&#39;particle_type_name&#39;</span><span class="p">]</span><span class="si">}{</span><span class="n">particle_index</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">particle_index</span>
                <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;monomer&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;monomer_type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">monomer</span>
                <span class="n">particle_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">particle</span><span class="p">)</span>
                <span class="n">particle_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">particle_list</span></div>

<div class="viewcode-block" id="CGModel.get_bond_list"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_bond_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_bond_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Construct a bond list for the coarse-grained model</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :returns: </span>
<span class="sd">             - bond_list ( List( List( int, int ) ) ) - A list of the bonds in the coarse-grained model.</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="n">bond_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bead_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_bond_forces</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">constrain_bonds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">monomer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">):</span>
                <span class="n">monomer_bond_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;bond_list&quot;</span><span class="p">]:</span>
                    <span class="n">monomer_bond_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">bead_index</span><span class="p">,</span> <span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bead_index</span><span class="p">])</span>

                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bead</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;particle_sequence&quot;</span><span class="p">]):</span>
                    <span class="c1"># first, connect the monomer to the last monomer</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]:</span>
                        <span class="c1"># first backbone bead is attached to the last backbone bead of previous monomer.</span>
                        <span class="n">bond_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">last_backbone_bead</span><span class="p">,</span> <span class="n">bead_index</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]:</span>
                        <span class="n">last_backbone_bead</span> <span class="o">=</span> <span class="n">bead_index</span>
                    <span class="n">bead_index</span> <span class="o">=</span> <span class="n">bead_index</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># increment for bookkeeping</span>
                <span class="n">bond_list</span> <span class="o">+=</span> <span class="n">monomer_bond_list</span>
        <span class="k">return</span> <span class="n">bond_list</span></div>

<div class="viewcode-block" id="CGModel.get_nonbonded_interaction_list"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_nonbonded_interaction_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_nonbonded_interaction_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Construct a nonbonded interaction list for the coarse-grained model</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :returns: </span>
<span class="sd">             - interaction_list ( List( List( int, int ) ) ) - A list of the nonbonded interactions (which don&#39;t violate exclusion rules) in the coarse-grained model</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="n">interaction_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_bond_forces</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">constrain_bonds</span><span class="p">:</span>
            <span class="n">bond_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bond_list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">particle_1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_beads</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">particle_2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">particle_1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_beads</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">[</span><span class="n">particle_1</span><span class="p">,</span> <span class="n">particle_2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bond_list</span> <span class="ow">and</span> <span class="p">[</span>
                        <span class="n">particle_2</span><span class="p">,</span>
                        <span class="n">particle_1</span><span class="p">,</span>
                    <span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bond_list</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">[</span><span class="n">particle_1</span><span class="p">,</span> <span class="n">particle_2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">interaction_list</span><span class="p">:</span>
                            <span class="k">if</span> <span class="p">[</span><span class="n">particle_2</span><span class="p">,</span> <span class="n">particle_1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">interaction_list</span><span class="p">:</span>
                                <span class="n">interaction_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">particle_1</span><span class="p">,</span> <span class="n">particle_2</span><span class="p">])</span>
                        <span class="k">if</span> <span class="p">[</span><span class="n">particle_2</span><span class="p">,</span> <span class="n">particle_1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">interaction_list</span><span class="p">:</span>
                            <span class="k">if</span> <span class="p">[</span><span class="n">particle_1</span><span class="p">,</span> <span class="n">particle_2</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">interaction_list</span><span class="p">:</span>
                                <span class="n">interaction_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">particle_2</span><span class="p">,</span> <span class="n">particle_1</span><span class="p">])</span>
            <span class="n">exclusion_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonbonded_exclusion_list</span>
            <span class="k">if</span> <span class="n">exclusion_list</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">exclusion</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">exclusion</span> <span class="ow">in</span> <span class="n">interaction_list</span><span class="p">:</span>
                        <span class="n">interaction_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">exclusion</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">[</span><span class="n">exclusion</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exclusion</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">([</span><span class="n">exclusion</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exclusion</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                        <span class="n">interaction_list</span><span class="o">.</span><span class="n">remove</span><span class="p">([</span><span class="n">exclusion</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">exclusion</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">particle_1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_beads</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">particle_2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">particle_1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_beads</span><span class="p">):</span>
                    <span class="n">interaction_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">particle_1</span><span class="p">,</span> <span class="n">particle_2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">interaction_list</span></div>

<div class="viewcode-block" id="CGModel.get_nonbonded_exclusion_list"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_nonbonded_exclusion_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_nonbonded_exclusion_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rosetta_functional_form</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Get a list of the nonbonded interaction exclusions, which are assigned if two particles are separated by less than three bonds</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :returns: </span>
<span class="sd">             - exclusion_list ( List( List( int, int ) ) ) - A list of the nonbonded particle interaction exclusions for the coarse-grained model</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="n">bond_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_list</span>
        <span class="n">exclusion_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># for now, we are INCLUDING intraresidue interactions, even though</span>
        <span class="c1"># this isn&#39;t traditional Rosetta functional form.</span>
        <span class="n">remove_intraresidue_interactions</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">rosetta_functional_form</span> <span class="ow">and</span> <span class="n">remove_intraresidue_interactions</span><span class="p">:</span>
            <span class="c1"># Remove interactions between particles in the same monomer</span>
            <span class="n">bead_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">monomer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">beadi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;num_beads&quot;</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">beadj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">beadi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;num_beads&quot;</span><span class="p">]):</span>
                        <span class="n">exclusion_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">bead_index</span> <span class="o">+</span> <span class="n">beadi</span><span class="p">,</span> <span class="n">bead_index</span> <span class="o">+</span> <span class="n">beadj</span><span class="p">])</span>
                <span class="n">bead_index</span> <span class="o">=</span> <span class="n">bead_index</span> <span class="o">+</span> <span class="n">monomer</span><span class="p">[</span><span class="s2">&quot;num_beads&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bond</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span> <span class="ow">and</span> <span class="n">bond</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">:</span>
                <span class="n">exclusion_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_angle_list</span><span class="p">:</span>
            <span class="n">angle_ends</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">angle_ends</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span> <span class="ow">and</span> <span class="n">angle_ends</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span><span class="p">:</span>
                <span class="n">exclusion_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">angle_ends</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rosetta_functional_form</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">torsion</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">torsion_list</span><span class="p">:</span>
                <span class="n">torsion_ends</span> <span class="o">=</span> <span class="p">[</span><span class="n">torsion</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">torsion</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">torsion_ends</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span>
                    <span class="ow">and</span> <span class="n">torsion_ends</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusion_list</span>
                <span class="p">):</span>
                    <span class="n">exclusion_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torsion_ends</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">exclusion_list</span></div>

<div class="viewcode-block" id="CGModel.get_bond_angle_list"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_bond_angle_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_bond_angle_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Construct a list of bond angles, which can be used to build bond angle potentials for the coarse-grained model</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :returns: </span>
<span class="sd">             - bond_angles ( List( List( int, int, int ) ) ) - A list of indices for all of the bond angles in the coarse-grained model</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="n">bond_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_list</span>
        <span class="n">bond_angles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Choose the first bond we will use to define a bond angle</span>
        <span class="k">for</span> <span class="n">bond_1</span> <span class="ow">in</span> <span class="n">bond_list</span><span class="p">:</span>
            <span class="c1"># Choose a second bond with which to attempt a bond angle</span>
            <span class="c1"># definition.</span>
            <span class="k">for</span> <span class="n">bond_2</span> <span class="ow">in</span> <span class="n">bond_list</span><span class="p">:</span>
                <span class="c1"># Make sure the bonds are different</span>
                <span class="k">if</span> <span class="n">bond_2</span> <span class="o">!=</span> <span class="n">bond_1</span> <span class="ow">and</span> <span class="p">[</span><span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">bond_1</span><span class="p">:</span>
                    <span class="c1"># Make sure the bonds share a common atom</span>
                    <span class="n">bond_angle</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bond_1</span> <span class="ow">or</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bond_1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">bond_angle</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">bond_angle</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">bond_angle</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">bond_angle</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bond_angles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bond_angle</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">bond_angle_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">bond_angles</span><span class="p">)</span>
                        <span class="n">bond_angles_temp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">bond_angle_set</span><span class="p">]</span>
                        <span class="n">bond_angle_reverse</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_angle</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bond_angle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">bond_angle</span> <span class="ow">in</span> <span class="n">bond_angles_temp</span><span class="p">,</span>
                                <span class="n">bond_angle_reverse</span> <span class="ow">in</span> <span class="n">bond_angles_temp</span><span class="p">,</span>
                            <span class="p">]</span>
                        <span class="p">):</span>
                            <span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                            <span class="n">bond_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond_angle</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bond_angles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">bond_angle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">bond_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond_angle</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bond_angles</span></div>

<div class="viewcode-block" id="CGModel.get_torsion_list"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_torsion_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_torsion_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># MRS: really slow, should be looked at.</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Construct a list of particle indices from which to define torsions for the coarse-grained model</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :returns: </span>
<span class="sd">            - torsions ( List( List( int, int, int, int ) ) ) - A list of the particle indices for the torsions in the coarse-grained model</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="n">bond_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_list</span>
        <span class="n">angle_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_angle_list</span>
        <span class="n">torsions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Choose the first bond in the torsion</span>
        <span class="k">for</span> <span class="n">bond_1</span> <span class="ow">in</span> <span class="n">bond_list</span><span class="p">:</span>
            <span class="c1"># Choose a second bond with which to attempt to define a torsion.</span>
            <span class="n">torsion</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bond_2</span> <span class="ow">in</span> <span class="n">bond_list</span><span class="p">:</span>
                <span class="c1"># Make sure bonds 1 and 2 are different</span>
                <span class="k">if</span> <span class="n">bond_2</span> <span class="o">!=</span> <span class="n">bond_1</span> <span class="ow">and</span> <span class="p">[</span><span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">bond_1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">torsion</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">torsion</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bond_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_2</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># Choose a third bond with which to attempt a torsion definition</span>
                    <span class="k">for</span> <span class="n">bond_3</span> <span class="ow">in</span> <span class="n">bond_list</span><span class="p">:</span>
                        <span class="c1"># Make sure the third bond is different from the first two bonds.</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">bond_3</span> <span class="o">!=</span> <span class="n">bond_1</span>
                            <span class="ow">and</span> <span class="p">[</span><span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">bond_1</span>
                            <span class="ow">and</span> <span class="n">bond_3</span> <span class="o">!=</span> <span class="n">bond_2</span>
                            <span class="ow">and</span> <span class="p">[</span><span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">bond_2</span>
                        <span class="p">):</span>
                            <span class="k">if</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">torsion</span> <span class="ow">or</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">torsion</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">torsion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                                    <span class="n">torsion</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="k">if</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">torsion</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                    <span class="n">torsion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                                <span class="k">if</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">torsion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                                    <span class="n">torsion</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                                <span class="k">if</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">torsion</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                    <span class="n">torsion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">torsion</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                                    <span class="n">torsion</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="k">if</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">torsion</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                    <span class="n">torsion</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">torsion</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                                    <span class="n">torsion</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                                <span class="k">if</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">torsion</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                                    <span class="n">torsion</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">bond_3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                            <span class="c1"># Determine if the particles defining this torsion are suitable.</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">torsions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">torsions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">for</span> <span class="n">existing_torsion</span> <span class="ow">in</span> <span class="n">torsions</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">Counter</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="n">Counter</span><span class="p">(</span><span class="n">existing_torsion</span><span class="p">):</span>
                                        <span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                                    <span class="n">torsions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">angle_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="n">bond_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">angle</span>
                    <span class="ow">and</span> <span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">angle</span>
                    <span class="ow">or</span> <span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">angle</span>
                    <span class="ow">and</span> <span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">angle</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">torsion</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                        <span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">for</span> <span class="n">existing_torsion</span> <span class="ow">in</span> <span class="n">torsions</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">Counter</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="n">Counter</span><span class="p">(</span><span class="n">existing_torsion</span><span class="p">):</span>
                                <span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                            <span class="n">torsions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">angle</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">torsion</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                        <span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">for</span> <span class="n">existing_torsion</span> <span class="ow">in</span> <span class="n">torsions</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">Counter</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="n">Counter</span><span class="p">(</span><span class="n">existing_torsion</span><span class="p">):</span>
                                <span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                            <span class="n">torsions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">torsion</span> <span class="o">=</span> <span class="p">[</span><span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                        <span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">for</span> <span class="n">existing_torsion</span> <span class="ow">in</span> <span class="n">torsions</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">Counter</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="n">Counter</span><span class="p">(</span><span class="n">existing_torsion</span><span class="p">):</span>
                                <span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                            <span class="n">torsions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">angle</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">torsion</span> <span class="o">=</span> <span class="p">[</span><span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                        <span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">for</span> <span class="n">existing_torsion</span> <span class="ow">in</span> <span class="n">torsions</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">Counter</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="o">==</span> <span class="n">Counter</span><span class="p">(</span><span class="n">existing_torsion</span><span class="p">):</span>
                                <span class="n">unique</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                            <span class="n">torsions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span>

        <span class="n">torsion_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="k">for</span> <span class="n">torsion</span> <span class="ow">in</span> <span class="n">torsions</span><span class="p">)</span>
        <span class="n">torsions</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">torsion</span><span class="p">)</span> <span class="k">for</span> <span class="n">torsion</span> <span class="ow">in</span> <span class="n">torsion_set</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">torsions</span></div>

<div class="viewcode-block" id="CGModel.get_particle_attribute"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_attribute">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">,</span> <span class="n">attribute</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get various attributes of a particle, given either the index or the particle dictionary</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;monomer&quot;</span><span class="p">,</span> <span class="s2">&quot;monomer_type&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">]:</span>
            <span class="c1"># these are attributes of the particles in the list</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">particle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">particle</span><span class="p">[</span><span class="n">attribute</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">particle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_list</span><span class="p">[</span><span class="n">particle</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attribute</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;charge&quot;</span><span class="p">,</span> <span class="s2">&quot;epsilon&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="s2">&quot;particle_type_name&quot;</span><span class="p">]:</span>
            <span class="c1"># these are attributes of the partilce type</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">particle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">particle</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">particle</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_list</span><span class="p">[</span><span class="n">particle</span><span class="p">][</span><span class="s2">&quot;type&quot;</span><span class="p">][</span><span class="n">attribute</span><span class="p">]</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="CGModel.get_particle_name"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Returns the name of a particle, given its index within the model</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_index: Index of the particle for which we would like to determine the type</span>
<span class="sd">          :type particle_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">            - particle_name ( str ) - The name of the particle</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_particle_index"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_index">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Returns the index of a particle, given its index within the model or the particle dictionary. Obviously,</span>
<span class="sd">          kind of redundant if using the index instead of the particle dictionary</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_index: Index of the particle for which we would like to determine the type</span>
<span class="sd">          :type particle_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">            - particle_name ( str ) - The name of the particle</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_particle_type"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Gives the type of a particle (a dictionary)</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle: Index of the particle for which we would like to determine the type OR partice dictionary</span>
<span class="sd">          :type particle: int or dict()</span>

<span class="sd">          :returns: </span>
<span class="sd">             - particle_type (str):</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_particle_type_name"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_type_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Gives the type of a particle.</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_index: Index of the particle for which we would like to determine the type OR partice dictionary</span>
<span class="sd">          :type particle_index: int or dict()</span>

<span class="sd">          :returns: </span>
<span class="sd">             - particle_type (str):</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;particle_type_name&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_particle_monomer_type"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_monomer_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_monomer_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Indicates which type of monomer a particle belongs to</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_index: Index of the particle for which we would like to determine the monomer type</span>
<span class="sd">          :type particle_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">             - monomer_type (dict) : monomer type</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;monomer_type&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_particle_monomer"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_monomer">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_monomer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Indicates which monomer index a particle belongs to</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_index: Index of the particle for which we would like to determine the monomer type</span>
<span class="sd">          :type particle_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">             - monomer_type (dict) : monomer type</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;monomer&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_particle_mass"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_mass">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Returns the mass of a particle, given its index within the coarse-grained model or the particle dictionary</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle: Index of the particle for which we would like to determine the type, or dict()</span>
<span class="sd">          :type particle: int or dict()</span>

<span class="sd">          :returns: </span>
<span class="sd">             - epsilon ( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) - The assigned Lennard-Jones epsilon value for the provided particle index</span>


<span class="sd">          &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;mass&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_particle_charge"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_charge">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_charge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Returns the charge for a particle, given its index within the coarse-grained model, or the dict</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_index: Index of the particle for which we would like to determine the type</span>
<span class="sd">          :type particle_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">            - particle_charge ( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) - The charge for the provided particle index</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;charge&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_particle_sigma"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_sigma">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Returns the Lennard-Jones potential sigma value for a particle, given the particle index</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_index: Index of the particle for which we would like to determine the type</span>
<span class="sd">          :type particle_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">            - sigma ( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) - The assigned Lennard-Jones sigma value for the provided particle index</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_particle_epsilon"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_particle_epsilon">[docs]</a>    <span class="k">def</span> <span class="nf">get_particle_epsilon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Returns the Lennard-Jones potential epsilon value for a particle, given its index within the coarse-grained model.</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_index: Index of the particle for which we would like to determine the type</span>
<span class="sd">          :type particle_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">             - epsilon ( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) - The assigned Lennard-Jones epsilon value for the provided particle index</span>


<span class="sd">          &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_attribute</span><span class="p">(</span><span class="n">particle</span><span class="p">,</span> <span class="s2">&quot;epsilon&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_bonded_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">particle_types</span><span class="p">,</span> <span class="n">force</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        internal function for returning any force value.</span>

<span class="sd">        parameters: the string name of the bonded force of interest</span>

<span class="sd">        returns: the value of the parameter for the atoms involved in the interaction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get the details for this force</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bonded_force_attributes</span><span class="p">[</span><span class="n">force</span><span class="p">]</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;suffix&quot;</span><span class="p">]</span>

        <span class="c1"># first, construct the name of the force that is needed.</span>
        <span class="n">string_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">reverse_string_name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">particle</span> <span class="ow">in</span> <span class="n">particle_types</span><span class="p">:</span>
            <span class="n">string_name</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">particle</span><span class="si">}</span><span class="s2">_&quot;</span>
        <span class="k">for</span> <span class="n">particle</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">particle_types</span><span class="p">):</span>
            <span class="n">reverse_string_name</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">particle</span><span class="si">}</span><span class="s2">_&quot;</span>

        <span class="n">string_name</span> <span class="o">+=</span> <span class="n">suffix</span>
        <span class="n">reverse_string_name</span> <span class="o">+=</span> <span class="n">suffix</span>

        <span class="n">parameter_value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">forces</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>

        <span class="n">default_name</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s2">&quot;default_name&quot;</span><span class="p">]</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="n">forces</span><span class="p">[</span><span class="n">default_name</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">parameter_value</span> <span class="o">=</span> <span class="n">forces</span><span class="p">[</span><span class="n">string_name</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">parameter_value</span> <span class="o">=</span> <span class="n">forces</span><span class="p">[</span><span class="n">reverse_string_name</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">force</span><span class="si">}</span><span class="s2"> definition provided for &#39;</span><span class="si">{</span><span class="n">string_name</span><span class="si">}</span><span class="s2">&#39;, setting to </span><span class="si">{</span><span class="n">default_value</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">forces</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">string_name</span><span class="p">:</span> <span class="n">default_value</span><span class="p">})</span>
                <span class="n">forces</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">reverse_string_name</span><span class="p">:</span> <span class="n">default_value</span><span class="p">})</span>
                <span class="n">parameter_value</span> <span class="o">=</span> <span class="n">forces</span><span class="p">[</span><span class="n">string_name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">parameter_value</span>

<div class="viewcode-block" id="CGModel.get_bond_length"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_bond_length">[docs]</a>    <span class="k">def</span> <span class="nf">get_bond_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Determines the correct bond length for two particles, given their indices.</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_1_index: Index for the first particle</span>
<span class="sd">          :type particle_1_index: int</span>

<span class="sd">          :param particle_2_index: Index for the second particle</span>
<span class="sd">          :type particle_2_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">             - bond_length ( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) - The assigned bond length for the provided particles</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="n">particle_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_parameter</span><span class="p">(</span><span class="n">particle_types</span><span class="p">,</span> <span class="s2">&quot;bond_lengths&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_bond_force_constant"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_bond_force_constant">[docs]</a>    <span class="k">def</span> <span class="nf">get_bond_force_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bond</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Determines the correct bond force constant for two particles, given their indices</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_1_index: Index for the first particle</span>
<span class="sd">          :type particle_1_index: int</span>

<span class="sd">          :param particle_2_index: Index for the second particle</span>
<span class="sd">          :type particle_2_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">             - bond_force_constant ( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) - The assigned bond force constant for the provided particles</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="n">particle_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">bond</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">bond</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_parameter</span><span class="p">(</span><span class="n">particle_types</span><span class="p">,</span> <span class="s2">&quot;bond_force_constants&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_equil_bond_angle"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_equil_bond_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_equil_bond_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Determines the correct equilibrium bond angle between three particles, given their indices within the coarse-grained model</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_1_index: Index for the first particle</span>
<span class="sd">          :type particle_1_index: int</span>

<span class="sd">          :param particle_2_index: Index for the second particle</span>
<span class="sd">          :type particle_2_index: int</span>

<span class="sd">          :param particle_3_index: Index for the third particle</span>
<span class="sd">          :type particle_3_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">            - equil_bond_angle (float) - The assigned equilibrium bond angle for the provided particles</span>

<span class="sd">          &quot;&quot;&quot;</span>

        <span class="n">particle_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_parameter</span><span class="p">(</span><span class="n">particle_types</span><span class="p">,</span> <span class="s2">&quot;equil_bond_angles&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_bond_angle_force_constant"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_bond_angle_force_constant">[docs]</a>    <span class="k">def</span> <span class="nf">get_bond_angle_force_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">          Determines the correct bond angle force constant for a bond angle between three particles, given their indices within the coarse-grained model</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param particle_1_index: Index for the first particle</span>
<span class="sd">          :type particle_1_index: int</span>

<span class="sd">          :param particle_2_index: Index for the second particle</span>
<span class="sd">          :type particle_2_index: int</span>

<span class="sd">          :param particle_3_index: Index for the third particle</span>
<span class="sd">          :type particle_3_index: int</span>

<span class="sd">          :returns: </span>
<span class="sd">             - bond_angle_force_constant ( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) - The assigned bond angle force constant for the provided particles</span>


<span class="sd">          &quot;&quot;&quot;</span>
        <span class="n">particle_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">angle</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_parameter</span><span class="p">(</span><span class="n">particle_types</span><span class="p">,</span> <span class="s2">&quot;bond_angle_force_constants&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_torsion_periodicity"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_torsion_periodicity">[docs]</a>    <span class="k">def</span> <span class="nf">get_torsion_periodicity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">torsion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;         </span>
<span class="sd">        Determines the correct periodicity for a torsion (bond angle involving four particles), given their indices within the coarse-grained model</span>

<span class="sd">        :param CGModel: CGModel() class object</span>
<span class="sd">        :type CGModel: class</span>

<span class="sd">        :param torsion: A list of the indices for the particles in a torsion</span>
<span class="sd">        :type torsion: List( int )</span>

<span class="sd">        :returns:</span>
<span class="sd">        - torsion_periodicity ( int ) - The periodicity for the input torsion</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">particle_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_parameter</span><span class="p">(</span><span class="n">particle_types</span><span class="p">,</span> <span class="s2">&quot;torsion_periodicities&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_torsion_force_constant"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_torsion_force_constant">[docs]</a>    <span class="k">def</span> <span class="nf">get_torsion_force_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">torsion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;         </span>
<span class="sd">          Determines the correct torsion force constant for a torsion (bond angle involving four particles), given their indices within the coarse-grained model</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param torsion: A list of the indices for the particles in a torsion</span>
<span class="sd">          :type torsion: List( int )</span>

<span class="sd">          :returns: </span>
<span class="sd">             - torsion_force_constant ( `Quantity() &lt;https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html&gt;`_ ) - The assigned torsion force constant for the provided particles</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="n">particle_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_parameter</span><span class="p">(</span><span class="n">particle_types</span><span class="p">,</span> <span class="s2">&quot;torsion_force_constants&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CGModel.get_equil_torsion_angle"><a class="viewcode-back" href="../../../cgmodel_class.html#cg_openmm.cg_model.cgmodel.CGModel.get_equil_torsion_angle">[docs]</a>    <span class="k">def</span> <span class="nf">get_equil_torsion_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">torsion</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;         </span>
<span class="sd">          Determines the correct equilibrium angle for a torsion (bond angle involving four particles), given their indices within the coarse-grained model</span>

<span class="sd">          :param CGModel: CGModel() class object</span>
<span class="sd">          :type CGModel: class</span>

<span class="sd">          :param torsion: A list of the indices for the particles in a torsion</span>
<span class="sd">          :type torsion: List( int )</span>

<span class="sd">          :returns: </span>
<span class="sd">             - equil_torsion_angle (float) - The assigned equilibrium torsion angle for the provided particles</span>

<span class="sd">          &quot;&quot;&quot;</span>
        <span class="n">particle_types</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_particle_type_name</span><span class="p">(</span><span class="n">torsion</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bonded_parameter</span><span class="p">(</span><span class="n">particle_types</span><span class="p">,</span> <span class="s2">&quot;equil_torsion_angles&quot;</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Shirts Group. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.3

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>